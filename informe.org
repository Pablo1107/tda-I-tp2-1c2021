#+LANGUAGE: es
#+OPTIONS: toc:nil title:nil
#+LATEX_CLASS_OPTIONS: [titlepage,a4paper]
#+LATEX_HEADER: \usepackage{a4wide}
#+LATEX_HEADER: \usepackage[colorlinks=true,linkcolor=black,urlcolor=blue,bookmarksopen=true]{hyperref}
#+LATEX_HEADER: \usepackage{bookmark}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \usepackage[spanish]{babel}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{float}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{svg}
#+LATEX_HEADER: \pagestyle{fancy}
#+LATEX_HEADER: \fancyhf{}
#+LATEX_HEADER: \fancyhead[L]{TP2 - Grupo 1}
#+LATEX_HEADER: \fancyhead[R]{Teoria de Algoritmos I - FIUBA}
#+LATEX_HEADER: \renewcommand{\headrulewidth}{0.4pt}
#+LATEX_HEADER: \fancyfoot[C]{\thepage}
#+LATEX_HEADER: \renewcommand{\footrulewidth}{0.4pt}
#+LATEX_HEADER: \usemintedstyle{stata-light}
#+LATEX_HEADER: \newminted{c}{bgcolor={rgb}{0.95,0.95,0.95}}

#+NAME: setup
#+BEGIN_SRC emacs-lisp :results silent :exports none
  (setq org-latex-minted-options
    '(("bgcolor" "bg")))
#+END_SRC
#+CALL: setup[:eval never-export :results none :exports none]()

#+BEGIN_EXPORT latex
\begin{titlepage}
	\hfill\includegraphics[width=6cm]{assets/logofiuba.jpg}
    \centering
    \vfill
    \Huge \textbf{Trabajo Práctico 2 — Algoritmos D\&C y Programacion Dinamica}
    \vskip2cm
    \Large [75.29/95.06] Teoria de Algoritmos I\\
    Primer cuatrimestre de 2022\\
    \vfill
    \begin{tabular}{ | l | l | l | }
      \hline
      Alumno & Padron & Email \\ \hline
      BENITO, Agustin & 108100 & abenito@fi.uba.ar \\ \hline
      BLÁZQUEZ, Sebastián & 99673 & sblazquez@fi.uba.ar \\ \hline
      DEALBERA, Pablo Andres & 106585 & pdealbera@fi.uba.ar \\ \hline
      DUARTE, Luciano & 105604 & lduarte@fi.uba.ar \\ \hline
      PICCO, Martín & 99289 & mpicco@fi.uba.ar \\ \hline
  	\end{tabular}
    \vfill
    \begin{tabular}{ | l | l | }
      \hline
      Entrega: & Primera \\ \hline
      Fecha: & Miercoles 27 de Abril del 2022 \\ \hline
  	\end{tabular}
    \vfill
    \vfill
\end{titlepage}
\tableofcontents
\newpage
\definecolor{bg}{rgb}{0.95,0.95,0.95}
#+END_EXPORT

* Parte 1: Un evento exclusivo
** Consigna :noexport:
Todos los años la asociación de un importante deporte individual profesional realiza una preclasificación de los n jugadores que terminaron en las mejores posiciones del ranking para un evento exclusivo. En la tarjeta de invitación que enviarán suelen adjuntar el número de posición en la que está actualmente y a cuantos rivales superó en el ranking (únicamente entre los invitados). Contamos con un listado que tiene el nombre del jugador y la posición del ranking del año pasado. Ese listado está ordenado por el ranking actual.

Ejemplo:

#+begin_src
A,3 | B,4 | C,2 | D,8 | E,6 | F,5 |

A → Ranking actual 1 → superó a 1 entre los preclasificados (C)
B → Ranking actual 2 → superó a 1 entre los preclasificados (C)
C → Ranking actual 3 → superó a 0 entre los preclasificados (-)
D → Ranking actual 4 → superó a 2 entre los preclasificados (E y F)
E → Ranking actual 5 → superó a 1 entre los preclasificados (F)
F → Ranking actual 6 → superó a 0 entre los preclasificados (-)
#+end_src

En este caso el problema debería retornar:

#+begin_src
A → 1 (1)
B → 2 (1)
C → 3 (0)
D → 4 (2)
E → 5 (1)
F → 6 (0)
#+end_src

Se pide:

  - Explicar cómo se puede resolver este problema por fuerza bruta. Analizar complejidad espacial y temporal de esta solución

  - Proponer una solución utilizando la metodología de división y conquista que sea más eficiente que la propuesta anterior. (incluya pseudocódigo y explicación)

  - Realizar el análisis de complejidad temporal mediante el uso del teorema maestro.

  - Realizar el análisis de complejidad temporal desenrollando la recurrencia

  - Analizar la complejidad espacial basándose en el pseudocódigo.

  - Dar un ejemplo completo del funcionamiento de su solución

* Parte 2: Ciclos negativos

** Consigna :noexport:

La detección de ciclos negativos tiene una variedad de aplicaciones en varios campos. Por ejemplo en el diseño de circuitos electrónicos VLSI, se requiere aislar los bucles de retroalimentación negativa. Estos corresponden a ciclos de costo negativo en el grafo de ganancia del amplificador del circuito. Tomando como entrada de nuestro problema un grafo ponderado con valores enteros (positivos y/o negativos) dirigido donde un nodo corresponde al punto de partida, queremos conocer si existe al menos un ciclo negativo y en caso afirmativo mostrarlo en pantalla.

Se pide:

  - Proponer una solución al problema que utiliza programación dinámica. Incluya relación de recurrencia, pseudocódigo, estructuras de datos utilizadas y explicación en prosa.

  - Analice la complejidad temporal y espacial de su propuesta.

  - Programe la solución

  - Determine si su programa tiene la misma complejidad que su propuesta teórica.

Formato de los archivos:

El programa debe recibir por parámetro el path del archivo donde se encuentra el grafo. El archivo con el grafo es un archivo de texto donde la primera línea corresponde al nodo inicial. Luego continúa con una línea por cada eje direccionado del grafo con el formato: ORIGEN,DESTINO,PESO.

Ejemplo: “grafo.txt”

#+begin_src
B
D,A,-2
B,A,3
D,C,2
C,D,-1
B,E,2
E,D,-2
A,E,3
...
#+end_src

Debe resolver el problema y retornar por pantalla la solución.

En caso de no existir ciclos negativos: “No existen ciclos negativos en el grafo”

En caso de existir ciclos negativos: “Existe al menos un ciclo negativo en el grafo. A,E,D → costo: -1”


** Algoritmo de Bellman-Ford

El algoritmo de Bellman-Ford es de tipo programacion dinamica y genera el camino
mas corto en un grafo dirigido ponderado a partir de un nodo origen y a
diferencia de Dijkstra permite hacerlo con grafos que tienen aristas con pesos
negativos y detecta ciclos negativos.

Este algoritmo se puede describir como los siguientes pasos:

  1. Iniciamos:
     - un diccionario de distancias con clave ~nodo/vertice~ y valor infinito.
     - un diccionario de predecesores con clave ~nodo/vertice~ y valor nulo.
     - la distancia de clave ~nodo_origen~ se cambia a 0.
  2. Iterar por la cantidad de nodos del grafo:
     - por cada arista, si la distancia guardada para llegar al origen de la
       arista mas el peso de moverse al nodo destino de la arista es menor a la
       distancia guardada para llegar al nodo destino de la arista, reemplazar la
       distancia guardada del nodo destino.
  3. Verificar que no haya ciclos negativos
     - por cada arista, si se sigue cumpliendo la condición del punto anterior,
       entonces hay un ciclo negativo


*** Relación de Recurrencia

Definiendo:
 - $s$: nodo origen o /source node/
 - $n_i$: otro nodo distinto al origen
 - $j$: longitud maxima para llegar de $s$ a $n_i$
 - $minPath(n_i, j)$: función recursiva para llegar al camino mínimo de $s$ a $n_i$
 - $n_x$: predecesores a $n_i$
 - $w(n_x,n_i)$: peso de la arista $n_x$ y $n_i$

$$minPath(S, j) = 0$$
$$minPath(n_i, 0) = +\infty\ \text{con}\ n_i \neq S$$
$$
minPath(n_i, j) = min \left\{ \begin{array}{lcc}
             minPath(n_i, j-1) \\
             min\ \{\ minPath(n_x, j-1) + w(n_x,n_i)\ \}
             \end{array}
   \right \}
$$

*** Pseudo-codigo


#+begin_src
funcion Bellman_Ford(Grafo grafo, Nodo origen)
    siendo distancias un diccionario
    siendo predecesores un diccionario

    por cada vertice v del grafo:
        distancias[v] = infinito

    distancias[origen] = 0
    padres[origen] = None

    por cada vertice:
        por cada arista de origen v y destino w y peso:
            si distancias[v] + peso < distancias[w]:
                predecesores[w] = v
                distancias[w] = distintas[v] + peso

    por cada arista de origen v y destino w y peso:
        si distancias[v] + peso < distancias[w]:
            tirar error "Hay un ciclo negativo"
#+end_src

** Detalles de implementación

El algoritmo fue implementado en Python y no tiene dependencias aparte de tener
instalado cualquier versión de ~python3~.

*** Ejecución del programa

El programa contiene un ~shebang~ para ser ejecutado en una terminal de la
siguiente forma:

#+begin_src bash :results raw
./src/parte_2.py <filename>
#+end_src

El comprimido entregado incluye un archivo ejemplo en ~assets/grafo.txt~ con grafos ejemplos,
por ejemplo:

#+begin_src
B
D,A,-2
B,A,3
D,C,2
C,D,-1
B,E,2
E,D,-2
A,E,3
#+end_src

#+begin_src bash :results raw
./src/parte_2.py ./assets/grafo.txt
#+end_src

#+begin_src
Existen al menos un ciclo negativo en el grafo. A,E,D → costo: -1
#+end_src

* Parte 3: Un poco de teoría

** Consigna :noexport:
1. Hasta el momento hemos visto 3 formas distintas de resolver problemas. Greedy, división y conquista y programación dinámica.

   1. Describa brevemente en qué consiste cada una de ellas

   2. ¿Cuál es la mejor de las 3? ¿Podría elegir una técnica sobre las otras?

2. Un determinado problema puede ser resuelto tanto por un algoritmo Greedy, como por un algoritmo de División y Conquista. El algoritmo greedy realiza N^3 operaciones sobre una matriz, mientras que el algoritmo de Programación Dinámica realiza N^2 operaciones en total, pero divide el problema en N^2 subproblemas a su vez, los cuales debe ir almacenando mientras se ejecuta el algoritmo. Teniendo en cuenta los recursos computacionales involucrados (CPU, memoria, disco) ¿Qué algoritmo elegiría para resolver el problema y por qué?

Pista: probablemente no haya una respuesta correcta para este problema, solo justificaciones correctas
