% Created 2022-04-17 Sun 01:17
% Intended LaTeX compiler: pdflatex
\documentclass[titlepage,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{a4wide}
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue,bookmarksopen=true]{hyperref}
\usepackage{bookmark}
\usepackage{fancyhdr}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{minted}
\usepackage{svg}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{TP2 - Grupo 1}
\fancyhead[R]{Teoria de Algoritmos I - FIUBA}
\renewcommand{\headrulewidth}{0.4pt}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{0.4pt}
\usemintedstyle{stata-light}
\newminted{c}{bgcolor={rgb}{0.95,0.95,0.95}}
\author{Pablo Andres Dealbera}
\date{\today}
\title{}
\begin{document}

\begin{titlepage}
	\hfill\includegraphics[width=6cm]{assets/logofiuba.jpg}
    \centering
    \vfill
    \Huge \textbf{Trabajo Práctico 2 — Algoritmos D\&C y Programacion Dinamica}
    \vskip2cm
    \Large [75.29/95.06] Teoria de Algoritmos I\\
    Primer cuatrimestre de 2022\\
    \vfill
    \begin{tabular}{ | l | l | l | }
      \hline
      Alumno & Padron & Email \\ \hline
      BENITO, Agustin & 108100 & abenito@fi.uba.ar \\ \hline
      BLÁZQUEZ, Sebastián & 99673 & sblazquez@fi.uba.ar \\ \hline
      DEALBERA, Pablo Andres & 106585 & pdealbera@fi.uba.ar \\ \hline
      DUARTE, Luciano & 105604 & lduarte@fi.uba.ar \\ \hline
      PICCO, Martín & 99289 & mpicco@fi.uba.ar \\ \hline
  	\end{tabular}
    \vfill
    \begin{tabular}{ | l | l | }
      \hline
      Entrega: & Primera \\ \hline
      Fecha: & Miercoles 27 de Abril del 2022 \\ \hline
  	\end{tabular}
    \vfill
    \vfill
\end{titlepage}
\tableofcontents
\newpage
\definecolor{bg}{rgb}{0.95,0.95,0.95}

\section{Parte 1: Un evento exclusivo}
\label{sec:org1041007}

\section{Parte 2: Ciclos negativos}
\label{sec:orgcfff3dd}

\subsection{Algoritmo de Bellman-Ford}
\label{sec:org42036ff}

El algoritmo de Bellman-Ford es de tipo programacion dinamica y genera el camino
mas corto en un grafo dirigido ponderado a partir de un nodo origen y a
diferencia de Dijkstra permite hacerlo con grafos que tienen aristas con pesos
negativos y detecta ciclos negativos.

Este algoritmo se puede describir como los siguientes pasos:

\begin{enumerate}
\item Iniciamos:
\begin{itemize}
\item un diccionario de distancias con clave \texttt{nodo/vertice} y valor infinito.
\item un diccionario de predecesores con clave \texttt{nodo/vertice} y valor nulo.
\item la distancia de clave \texttt{nodo\_origen} se cambia a 0.
\end{itemize}
\item Iterar por la cantidad de nodos del grafo:
\begin{itemize}
\item por cada arista, si la distancia guardada para llegar al origen de la
arista mas el peso de moverse al nodo destino de la arista es menor a la
distancia guardada para llegar al nodo destino de la arista, reemplazar la
distancia guardada del nodo destino.
\end{itemize}
\item Verificar que no haya ciclos negativos
\begin{itemize}
\item por cada arista, si se sigue cumpliendo la condición del punto anterior,
entonces hay un ciclo negativo
\end{itemize}
\end{enumerate}


\subsubsection{Relación de Recurrencia}
\label{sec:orgcb0350c}

Definiendo:
\begin{itemize}
\item \(s\): nodo origen o \emph{source node}
\item \(n_i\): otro nodo distinto al origen
\item \(j\): longitud maxima para llegar de \(s\) a \(n_i\)
\item \(minPath(n_i, j)\): función recursiva para llegar al camino mínimo de \(s\) a \(n_i\)
\item \(n_x\): predecesores a \(n_i\)
\item \(w(n_x,n_i)\): peso de la arista \(n_x\) y \(n_i\)
\end{itemize}

$$minPath(S, j) = 0$$
$$minPath(n_i, 0) = +\infty\ \text{con}\ n_i \neq S$$
$$
minPath(n_i, j) = min \left\{ \begin{array}{lcc}
             minPath(n_i, j-1) \\
             min\ \{\ minPath(n_x, j-1) + w(n_x,n_i)\ \}
             \end{array}
   \right \}
$$

\subsubsection{Pseudo-codigo}
\label{sec:org68d106f}


\begin{verbatim}
funcion Bellman_Ford(Grafo grafo, Nodo origen)
    siendo distancias un diccionario
    siendo predecesores un diccionario

    por cada vertice v del grafo:
        distancias[v] = infinito

    distancias[origen] = 0
    padres[origen] = None

    por cada vertice:
        por cada arista de origen v y destino w y peso:
            si distancias[v] + peso < distancias[w]:
                predecesores[w] = v
                distancias[w] = distintas[v] + peso

    por cada arista de origen v y destino w y peso:
        si distancias[v] + peso < distancias[w]:
            tirar error "Hay un ciclo negativo"
\end{verbatim}

\subsection{Detalles de implementación}
\label{sec:org00f3d41}

El algoritmo fue implementado en Python y no tiene dependencias aparte de tener
instalado cualquier versión de \texttt{python3}.

\subsubsection{Ejecución del programa}
\label{sec:org950b3e5}

El programa contiene un \texttt{shebang} para ser ejecutado en una terminal de la
siguiente forma:

\begin{minted}[]{bash}
./src/parte_2.py <filename>
\end{minted}

El comprimido entregado incluye un archivo ejemplo en \texttt{assets/grafo.txt} con grafos ejemplos,
por ejemplo:

\begin{verbatim}
B
D,A,-2
B,A,3
D,C,2
C,D,-1
B,E,2
E,D,-2
A,E,3
\end{verbatim}

\begin{minted}[]{bash}
./src/parte_2.py ./assets/grafo.txt
\end{minted}

\begin{verbatim}
Existen al menos un ciclo negativo en el grafo. A,E,D → costo: -1
\end{verbatim}

\section{Parte 3: Un poco de teoría}
\label{sec:orgc10b237}
\end{document}
