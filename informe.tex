% Created 2022-04-21 Thu 00:15
% Intended LaTeX compiler: pdflatex
\documentclass[titlepage,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{a4wide}
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue,bookmarksopen=true]{hyperref}
\usepackage{bookmark}
\usepackage{fancyhdr}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{minted}
\usepackage{svg}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{TP2 - Grupo 1}
\fancyhead[R]{Teoria de Algoritmos I - FIUBA}
\renewcommand{\headrulewidth}{0.4pt}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{0.4pt}
\usemintedstyle{stata-light}
\newminted{c}{bgcolor={rgb}{0.95,0.95,0.95}}
\author{Pablo Andres Dealbera}
\date{\today}
\title{}
\begin{document}

\begin{titlepage}
	\hfill\includegraphics[width=6cm]{assets/logofiuba.jpg}
    \centering
    \vfill
    \Huge \textbf{Trabajo Práctico 2 — Algoritmos D\&C y Programacion Dinamica}
    \vskip2cm
    \Large [75.29/95.06] Teoria de Algoritmos I\\
    Primer cuatrimestre de 2022\\
    \vfill
    \begin{tabular}{ | l | l | l | }
      \hline
      Alumno & Padron & Email \\ \hline
      BENITO, Agustin & 108100 & abenito@fi.uba.ar \\ \hline
      BLÁZQUEZ, Sebastián & 99673 & sblazquez@fi.uba.ar \\ \hline
      DEALBERA, Pablo Andres & 106585 & pdealbera@fi.uba.ar \\ \hline
      DUARTE, Luciano & 105604 & lduarte@fi.uba.ar \\ \hline
      PICCO, Martín & 99289 & mpicco@fi.uba.ar \\ \hline
  	\end{tabular}
    \vfill
    \begin{tabular}{ | l | l | }
      \hline
      Entrega: & Primera \\ \hline
      Fecha: & Miercoles 27 de Abril del 2022 \\ \hline
  	\end{tabular}
    \vfill
    \vfill
\end{titlepage}
\tableofcontents
\newpage
\definecolor{bg}{rgb}{0.95,0.95,0.95}

\section{Parte 1: Un evento exclusivo}
\label{sec:org3abbcdd}

\section{Parte 2: Ciclos negativos}
\label{sec:org7d96b7a}

En esta segunda parte del trabajo practico, se nos presenta el problema de
analizar un grafo dirigido ponderado con valores enteros y verificar si tiene,
por lo menos, un ciclo negativo. En el caso de tenerlo, debemos mostrar en
pantalla los nodos que contienen a dicho ciclo. Además, se nos pide que la
solución presentada utilice programación dinámica.

\subsection{Solución con Bellman-Ford}
\label{sec:org61a5150}
Para resolver el problema enunciado podemos utilizar el algoritmo Bellman-Ford
para calcular el camino mínimo en un grafo ponderado con aristas negativas a
partir de un nodo de origen. Lógicamente, no podría encontrarse un camino mínimo
distinto a (menos infinito) si es que hay ciclos negativos. Esto es porque
caeríamos en un punto donde resulta conveniente recorrer dicho ciclo
infinitamente ya que cada vez se reduce más la longitud del camino mínimo. Vamos
a ver que esto puede ser utilizado para encontrar ciclos negativos.


\hfill

Primero, veamos como calcular el camino mínimo:

\subsubsection{Algoritmo}
\label{sec:org98787eb}

Primero, se inicializa la distancia del nodo de origen \(n_s\) hasta todos los
vértices como infinito y la distancia al nodo \(n_s\) como cero. Luego por cada
arista se verifica si la distancia guardada para llegar al vértice de origen de
la arista sumado al peso de la arista es menor a la guardada para llegar al
vértice destino de la arista. Esto se repite \(N – 1\) veces con \(N\) el número de
nodos del grafo. De esta manera, en cada iteración \(i\), el algoritmo encuentra el
camino mínimo de longitud máxima \(i\). Es por esto que el ciclo se repite \(N – 1\)
veces, porque el camino mínimo sin ciclos podría ser de esa longitud. Es en este
punto donde el algoritmo nos es de utilidad. Podemos aplicar el mismo
procedimiento una vez, es decir viendo si se puede encontrar un camino mínimo de
longitud \(N\) que sea menor al encontrado de longitud \(N – 1\). Si esto sucede,
implica que estamos agregando una arista negativa formando un ciclo negativo. Es
decir, identificamos el ciclo negativo que se nos pide en el enunciado.

\hfill

El algoritmo de Bellman-Ford termina ahí, en el caso de encontrar un ciclo
negativo devuelve error y en caso contrario devuelve el camino mínimo o una
estructura para reconstruirlo. En nuestro caso, necesitamos adaptar el algoritmo
para que devuelva un ciclo negativo si es que hay o nada en caso de no haber.
Entonces, lo que podemos hacer es una vez que sabemos que hay un ciclo negativo,
iterar una vez mas y reconstruir el ciclo negativo.

\pagebreak

\begin{enumerate}
\item Pseudo-codigo
\label{sec:org62872e0}

\begin{verbatim}
funcion Bellman_Ford(Grafo grafo, Nodo origen)
    siendo distancias un diccionario
    siendo predecesores un diccionario

    por cada vertice v del grafo:
        distancias[v] = infinito

    distancias[origen] = 0
    padres[origen] = None

    por cada vertice:
        por cada arista de origen v y destino w y peso:
            si distancias[v] + peso < distancias[w]:
                predecesores[w] = v
                distancias[w] = distintas[v] + peso

    por cada arista de origen v y destino w y peso:
        si distancias[v] + peso < distancias[w]:
            tirar error "Hay un ciclo negativo"
\end{verbatim}
\end{enumerate}

\subsubsection{Complejidad}
\label{sec:org700b310}

Podemos analizar la complejidad a partir del pseudo-codigo. Primero, tenemos un
ciclo donde inicializamos las distancias de cada vértice al origen como
infinito. Es decir O(V), donde V es la cantidad de vértices. Luego, por cada
vértice sin contar el origen recorremos todas las aristas adyacentes que en el
peor de los casos resulta O(E). Es decir que el ciclo entero tiene una
complejidad de O(V * E). Finalmente, encontrar el ciclo negativo y devolverlo
tiene una complejidad de O(E) porque se recorren todas las aristas una vez más.
Entonces, la complejidad final del algoritmo es de O(V * E).

\subsubsection{Relación de Recurrencia}
\label{sec:orga8a2b3c}

Sea \(n_s\) en nodo de inicio, \(T\) el nodo final, \(N_i\) un nodo y \(predecesores[N_i]\) es el
conjunto de los nodos adyacentes a \(N_i\), sabemos que para llegar desde el nodo \(n_s\)
al nodo \(N_i\) en una cantidad de pasos \(j\) debemos haber llegado a alguno de sus
predecesores en \(j-1\) pasos. Entonces, siendo la longitud la cantidad de nodos que
se recorren hasta llegar al nodo \(N_i\), se deduce de lo planteado que el camino
mínimo hasta el nodo \(N_i\) dada una longitud máxima \(L\) es el mínimo de los caminos
hacia sus predecesores mas la longitud de llegar del predecesor a \(N_i\). Por lo
tanto, nuestra ecuación de recurrencia resulta:

Definiendo:
\begin{itemize}
\item \(n_s\): nodo origen o \emph{source node}
\item \(n_i\): otro nodo distinto al origen
\item \(j\): longitud máxima para llegar de \(n_s\) a \(n_i\)
\item \(minPath(n_i, j)\): función recursiva para llegar al camino mínimo de \(s\) a \(n_i\)
\item \(n_x\): predecesores a \(n_i\)
\item \(k\): cantidad de predecesores a \(n_i\)
\item \(w(n_x,n_i)\): peso de la arista \(n_x\) y \(n_i\)
\end{itemize}

$$minPath(n_s, j) = 0$$
$$minPath(n_i, 0) = +\infty\ \text{con}\ n_i \neq S$$
$$
minPath(n_i, j) = min \left\{\begin{array}{lcc}
                        minPath(n_i, j-1) \\
                        min\ \left\{\begin{array}{lcc}
                               minPath(n_x_1, j-1) + w(n_x_1,n_i) \\
                               minPath(n_x_2, j-1) + w(n_x_2,n_i) \\
                               ... \\
                               minPath(n_x_k, j-1) + w(n_x_k,n_i)
                             \end{array}\right\}
                      \end{array}\right\}
$$

\subsection{Detalles de implementación}
\label{sec:org8af2814}

El algoritmo fue implementado en Python y no tiene dependencias aparte de tener
instalado cualquier versión de \texttt{python3}.

\subsubsection{Ejecución del programa}
\label{sec:org5c28f5a}

El programa contiene un \texttt{shebang} para ser ejecutado en una terminal de la
siguiente forma:

\begin{minted}[]{bash}
./src/parte_2.py <filename>
\end{minted}

El comprimido entregado incluye un archivo ejemplo en \texttt{assets/grafo.txt} con grafos ejemplos,
por ejemplo:

\begin{verbatim}
B
D,A,-2
B,A,3
D,C,2
C,D,-1
B,E,2
E,D,-2
A,E,3
\end{verbatim}

\begin{minted}[]{bash}
./src/parte_2.py ./assets/grafo.txt
\end{minted}

\begin{verbatim}
Existen al menos un ciclo negativo en el grafo. A,E,D → costo: -1
\end{verbatim}

\subsubsection{Estructuras de datos}
\label{sec:org2d18e4c}

Para la representación del grafo decidimos manteneral simple:
\begin{itemize}
\item Un lista de aristas para almacenar las aristas tal cual como estan en el archivo.
\item Un set de vértices para mantener un registro de los vértices ingresados en
cada arista.
\end{itemize}

\pagebreak

\subsubsection{Implementación de Bellman-Ford en Python}
\label{sec:org7fe2c15}

Pasando el pseudo-codigo a Python obtenemos este resultado:

\begin{minted}[]{python}
def Bellman_Ford(grafo, origen):                         # O(V * E)
    dist = {}
    predecesores = {}

    # Inicializar distancias en infinito
    for v in grafo.vertices:                             # O(V)
        dist[v] = float("inf")

    # Inicializar distancias al origen en cero y
    dist[origen] = 0
    predecesores[origen] = None

    # Ejecutar por cada vertice
    for _ in grafo.vertices:                             # O(V * E)
        cambio = False
        for v, w, peso in grafo.aristas:                 # O(E)
            if dist[v] + peso < dist[w]:
                cambio = True
                predecesores[w] = v
                dist[w] = dist[v] + peso

        if not cambio:
            return

    # Chequear si hay ciclos negativos
    # y calcular dicho ciclo y su peso
    ciclo = []
    peso_ciclo = 0
    for v, w, peso in grafo.aristas:                     # O(E)
        if dist[v] + peso < dist[w]:
            ciclo.append(v)
            arista_actual = v
            predecesor = predecesores[v]
            peso_ciclo = grafo.peso(predecesor, arista_actual)

            while predecesor != v:
                ciclo.append(predecesor)
                arista_actual = predecesor
                predecesor = predecesores[predecesor]
                peso_actual = grafo.peso(predecesor, arista_actual)
                peso_ciclo += peso_actual

            return ciclo[::-1], peso_ciclo               # O(V)
\end{minted}

Al igual que el pseudo-codigo, podemos describir la implementacion de la
siguiente manera:

\begin{enumerate}
\item Iniciamos:
\begin{itemize}
\item un diccionario de distancias con clave \texttt{vertice} y valor infinito.
\item un diccionario de predecesores donde la clave \texttt{origen} se inicializa en \texttt{None}
\item la distancia de clave \texttt{origen} se cambia a \texttt{0}.
\end{itemize}
\item Iterar por la cantidad de vértices del grafo:
\begin{itemize}
\item por cada arista, si la distancia guardada para llegar al origen de la
arista mas el peso de moverse al nodo destino de la arista es menor a la
distancia guardada para llegar al nodo destino de la arista, reemplazar la
distancia guardada del nodo destino.
\item ademas, verificamos si no hubo un cambio en la iteración de aristas, si
este es el caso, podemos confirmar que no existe ningún ciclo negativo
por lo que devolvemos.
\end{itemize}
\item Verificar que no haya ciclos negativos
\begin{itemize}
\item por cada arista, si se sigue cumpliendo la condición del punto anterior,
entonces hay un ciclo negativo
\item si hay un ciclo negativo:
\begin{itemize}
\item reconstruir los nodos predecesores hasta llegar al nodo que se detecto
y sumar los pesos de sus aristas.
\item devolver el ciclo negativo y su peso
\end{itemize}
\end{itemize}
\end{enumerate}


\subsubsection{Calcular ciclo negativo}
\label{sec:orgff872c5}

A partir del algoritmo de Bellman-Ford agregamos código cuando se detecta el
ciclo negativo que agrega el nodo que se detecto termina el ciclo negativo y se
reconstruye los nodos predecesores iterando hasta volver al nodo original
mientras que se suman todos sus pesos en la variable \texttt{peso\_ciclo}.

Luego devolvemos al \texttt{ciclo} reconstruido invertido y el \texttt{peso\_ciclo} calculado.

\subsubsection{Complejidad de la implementación}
\label{sec:org24d18b0}

Con la simple estructura que decidimos usar, el codigo y el pseudo-codigo tiene
pocas diferencias, y la complejidad termina siendo la misma \(O(V * E)\).

\section{Parte 3: Un poco de teoría}
\label{sec:org83eb617}
\end{document}
